# Copyright (c) 2008-2009 AG Projects
# Copyright 2018 gevent community
# Author: Denis Bilenko
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.


import unittest

import gevent.hub

# It's important to do this ASAP, because if we're monkey patched,
# then importing things like the standard library test.support can
# need to construct the hub (to check for IPv6 support using a socket).
# We can't do it in the testrunner, as the testrunner spawns new, unrelated
# processes.
from .hub import QuietHub

# pylint:disable=unused-import

gevent.hub.set_default_hub_class(QuietHub)

try:
    import faulthandler
except ImportError:
    # The backport isn't installed.
    pass
else:
    # Enable faulthandler for stack traces. We have to do this here
    # for the same reasons as above.
    faulthandler.enable()

try:
    from gevent.libuv import _corecffi
except ImportError:
    pass
else:
    _corecffi.lib.gevent_test_setup() # pylint:disable=no-member
    del _corecffi

from .exception import ExpectedException
from .leakcheck import ignores_leakcheck
from .params import (DEFAULT_BIND_ADDR, DEFAULT_BIND_ADDR_TUPLE,
                     DEFAULT_CONNECT_HOST, DEFAULT_LOCAL_HOST_ADDR,
                     DEFAULT_LOCAL_HOST_ADDR6, DEFAULT_SOCKET_TIMEOUT,
                     DEFAULT_XPC_SOCKET_TIMEOUT, LARGE_TIMEOUT)
from .skipping import (skipIf, skipOnAppVeyor, skipOnCI, skipOnLibev,
                       skipOnLibuv, skipOnLibuvOnCI, skipOnLibuvOnCIOnPyPy,
                       skipOnLibuvOnPyPyOnWin, skipOnLibuvOnTravisOnCPython27,
                       skipOnLibuvOnWin, skipOnMacOnCI, skipOnManylinux,
                       skipOnPurePython, skipOnPy2, skipOnPy3, skipOnPy37,
                       skipOnPy310, skipOnPyPy, skipOnPyPy3, skipOnPyPy3OnCI,
                       skipOnPyPyOnCI, skipOnPyPyOnWindows, skipOnWindows,
                       skipUnless, skipWithCExtensions,
                       skipWithoutExternalNetwork, skipWithoutResource)
from .sysinfo import (CFFI_BACKEND, CONN_ABORTED_ERRORS, CPYTHON, DEBUG,
                      EXPECT_POOR_TIMER_RESOLUTION, LIBUV, LINUX,
                      NON_APPLICABLE_SUFFIXES, OSX, PLATFORM_SPECIFIC_SUFFIXES,
                      PY2, PY3, PY36, PY37, PY38, PY39, PY310, PYPY, PYPY3,
                      RESOLVER_ARES, RESOLVER_DNSPYTHON, RESOLVER_NOT_SYSTEM,
                      RUN_COVERAGE, RUN_LEAKCHECKS, RUNNING_ON_APPVEYOR,
                      RUNNING_ON_CI, RUNNING_ON_TRAVIS,
                      SHARED_OBJECT_EXTENSION, VERBOSE, WIN,
                      resolver_dnspython_available)

main = unittest.main
SkipTest = unittest.SkipTest




from .modules import walk_modules
from .openfiles import get_number_open_files, get_open_files
from .sockets import bind_and_listen, tcp_listener
from .testcase import TestCase

BaseTestCase = unittest.TestCase

from .flaky import (reraiseFlakyTestRaceCondition, reraiseFlakyTestTimeout,
                    reraises_flaky_race_condition, reraises_flaky_timeout)


def gc_collect_if_needed():
    "Collect garbage if necessary for destructors to run"
    import gc
    if PYPY: # pragma: no cover
        gc.collect()

# Our usage of mock should be limited to '@mock.patch()'
# and other things that are easily...mocked...here on Python 2
# when mock is not installed.
try:
    from unittest import mock
except ImportError: # Python 2
    try:
        import mock
    except ImportError: # pragma: no cover
        # Backport not installed
        class mock(object):

            @staticmethod
            def patch(reason):
                return unittest.skip(reason)

mock = mock


# zope.interface
from zope.interface import verify
